import 'package:flutter/foundation.dart';
import '../../domain/entities/entities.dart';
import '../../data/datasources/memory.dart';
import '../../data/repositories/impl.dart';
import '../../domain/usecases/search_books.dart';
import '../../domain/usecases/add_to_cart.dart';
import '../../domain/usecases/remove_from_cart.dart';
import '../../domain/usecases/update_qty_cart.dart';
import '../../domain/usecases/toggle_wishlist.dart';
import '../../domain/usecases/place_order.dart';
import '../../domain/usecases/list_orders.dart';
import '../../domain/usecases/filter_by_category.dart';
import '../../domain/usecases/get_book_detail.dart';
import '../../domain/usecases/clear_cart.dart';

enum SortType { popular, newest, priceAsc, priceDesc, rating }

class AppState extends ChangeNotifier {
  late final MemoryDataSource _ds;
  late final BookRepositoryImpl _bookRepo;
  late final CartRepositoryImpl _cartRepo;
  late final WishlistRepositoryImpl _wishlistRepo;
  late final OrderRepositoryImpl _orderRepo;

  late final SearchBooks searchBooks;
  late final AddToCart addToCart;
  late final RemoveFromCart removeFromCart;
  late final UpdateQtyCart updateQtyCart;
  late final ToggleWishlist toggleWishlistUc;
  late final PlaceOrder placeOrderUc;
  late final ListOrders listOrdersUc;
  late final FilterByCategory filterByCategory;
  late final GetBookDetail getBookDetail;
  late final ClearCart clearCartUc;

  List<Book> catalog = [];
  List<Book> catalogView = [];
  List<CartItem> cart = [];
  List<String> wishlistIds = [];
  List<Order> orders = [];

  String currentQuery = '';
  String? currentCategory;
  SortType sortType = SortType.popular;

  Address? shippingAddress;
  String? couponCode;
  final int shippingFeeBase = 15000;

  final Map<String, List<Review>> _reviewsCache = {};

  Future<void> init() async {
    _ds = MemoryDataSource();
    _bookRepo = BookRepositoryImpl(_ds);
    _cartRepo = CartRepositoryImpl(_ds);
    _wishlistRepo = WishlistRepositoryImpl(_ds);
    _orderRepo = OrderRepositoryImpl(_ds);

    searchBooks = SearchBooks(_bookRepo);
    addToCart = AddToCart(_cartRepo);
    removeFromCart = RemoveFromCart(_cartRepo);
    updateQtyCart = UpdateQtyCart(_cartRepo);
    toggleWishlistUc = ToggleWishlist(_wishlistRepo);
    placeOrderUc = PlaceOrder(_orderRepo, _cartRepo);
    listOrdersUc = ListOrders(_orderRepo);
    filterByCategory = FilterByCategory(_bookRepo);
    getBookDetail = GetBookDetail(_bookRepo);
    clearCartUc = ClearCart(_cartRepo);

    catalog = await _bookRepo.listAll();
    catalogView = _applySort(catalog);
    cart = await _cartRepo.getCart();
    wishlistIds = await _wishlistRepo.getWishlistIds();
    orders = await listOrdersUc();
    notifyListeners();
  }

  List<Book> _applySort(List<Book> src) {
    final list = [...src];
    switch (sortType) {
      case SortType.popular:
        list.sort((a,b) => b.soldCount.compareTo(a.soldCount));
        break;
      case SortType.newest:
        list.sort((a,b) => (b.publishedAt ?? DateTime(1970))
            .compareTo(a.publishedAt ?? DateTime(1970)));
        break;
      case SortType.priceAsc:
        list.sort((a,b) => a.price.compareTo(b.price));
        break;
      case SortType.priceDesc:
        list.sort((a,b) => b.price.compareTo(a.price));
        break;
      case SortType.rating:
        list.sort((a,b) => b.ratingAvg.compareTo(a.ratingAvg));
        break;
    }
    return list;
  }

  void setSort(SortType t) {
    sortType = t;
    doSearch(currentQuery); // sẽ gọi notify trong doSearch
  }

  Future<void> doSearch(String q) async {
    currentQuery = q;
    List<Book> base;
    if (q.trim().isEmpty) {
      base = await _bookRepo.listAll();
    } else {
      base = await searchBooks(q);
    }
    if (currentCategory != null && currentCategory!.isNotEmpty) {
      base = base.where((b) => b.category.toLowerCase() == currentCategory!.toLowerCase()).toList();
    }
    catalogView = _applySort(base);
    notifyListeners();
  }

  Future<void> applyCategory(String? cat) async {
    currentCategory = cat;
    await doSearch(currentQuery);
  }

  Future<void> toggleWishlist(String bookId) async {
    wishlistIds = await toggleWishlistUc(bookId);
    notifyListeners();
  }

  Future<void> addOne(Book book) async {
    await addToCart(CartItem(book: book, qty: 1));
    cart = await _cartRepo.getCart();
    notifyListeners();
  }

  Future<void> decOne(String bookId) async {
    final i = cart.indexWhere((e) => e.book.id == bookId);
    if (i >= 0) {
      final nextQty = cart[i].qty - 1;
      if (nextQty <= 0) {
        await removeFromCart(bookId);
      } else {
        await updateQtyCart(bookId, nextQty);
      }
      cart = await _cartRepo.getCart();
      notifyListeners();
    }
  }

  Future<void> incOne(String bookId) async {
    final i = cart.indexWhere((e) => e.book.id == bookId);
    if (i >= 0) {
      await updateQtyCart(bookId, cart[i].qty + 1);
      cart = await _cartRepo.getCart();
      notifyListeners();
    }
  }

  Future<void> removeItem(String bookId) async {
    await removeFromCart(bookId);
    cart = await _cartRepo.getCart();
    notifyListeners();
  }

  Future<void> clearCart() async {
    await clearCartUc();
    cart = [];
    notifyListeners();
  }

  int get subtotal => cart.fold(0, (s, e) => s + e.book.price * e.qty);

  int get discount {
    if (couponCode == null) return 0;
    if (couponCode!.toUpperCase() == 'FIT30') return (subtotal * 0.3).round();
    return 0;
  }

  int get shippingFee {
    if (couponCode?.toUpperCase() == 'FREESHIP') return 0;
    if (cart.isEmpty) return 0;
    return shippingFeeBase;
  }

  int get payable => (subtotal - discount + shippingFee).clamp(0, 1 << 31);

  void setCoupon(String? code) {
    couponCode = (code ?? '').trim().isEmpty ? null : code!.trim();
    notifyListeners();
  }

  void setAddress(Address a) {
    shippingAddress = a;
    notifyListeners();
  }

  Future<Order?> placeCurrentOrder() async {
    if (cart.isEmpty) return null;
    await placeOrderUc(cart, payable);
    orders = await listOrdersUc();
    final created = orders.isNotEmpty ? orders.last : null;
    cart = [];
    notifyListeners();
    return created;
  }

  Future<void> buyNow(Book book) async {
    await clearCartUc();
    cart = [];
    await addToCart(CartItem(book: book, qty: 1));
    cart = await _cartRepo.getCart();
    await placeCurrentOrder();
  }

  Future<List<Review>> getReviews(String bookId) async {
    if (_reviewsCache.containsKey(bookId)) return _reviewsCache[bookId]!;
    final list = await _ds.loadReviews(bookId);
    _reviewsCache[bookId] = list;
    return list;
  }

  Future<double> getAverageRating(String bookId) async {
    final list = await getReviews(bookId);
    if (list.isEmpty) return 0;
    final sum = list.fold<int>(0, (s, e) => s + e.rating);
    return sum / list.length;
  }

  Future<void> addReview(String bookId, int rating, String text) async {
    final review = Review(rating: rating, text: text, createdAt: DateTime.now());
    await _ds.addReview(bookId, review);
    _reviewsCache.remove(bookId);
    notifyListeners();
  }
}
